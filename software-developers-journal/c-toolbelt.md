# A C Developer's Utility Belt

**Jealousy** is an emotion commonly associated with C developers.
It's easy to see why; developing in other languages is just so *nice*.
Automated refactoring, dynamic reloading, garbage collection, exceptions, object-orientation, lambdas…
You've got to give up a lot to work in C.

But it doesn't have to suck.
You don't have to leave **all** your best tools behind.
If you find yourself writing C, don't deny yourself the benefit of all the techniques that have worked so well for other languages.
These are things that help make software projects *in any language* successful, and many of them can still work for you.

But first, before you start writing code, there are a couple of questions you should ask yourself.


### What are you building?
What form does your final product take?
Is your software installed on strangers' computers, or does it run on a server under your control?
There are many ways to ask this question, but it boils down to just one: *"Are you shipping source code, or binaries?"*

Distributing pre-built binaries has some advantages.
If you want to keep your source code secret, this is the clear choice; it's difficult to recover source code from a compiled binary, so much so that you can think of an optimizing compiler as a sort of weak encryption tool.

You also have more control over the development environment – you know the exact compiler(s) that your code needs to work with.
Having complete control over your toolchain lets you avoid cluttering your code up with compiler-compatibility workarounds, or testing with esoteric compilers.

However, if you're giving away your source code, you have access to a broader developer base.
Opening your code away has some obvious advantages, like having complete strangers chip in to fix a bug or add a feature.
But there are other, subtler advantages, like the goodwill generated by participating in the community surrounding your project, and the ability to recruit and interview more effectively.

One of my favorite subtle side-effects is style-guide compliance.
If my code is shared not only with my colleagues, but with everyone (including my personal heroes), I take extra care to make sure it's readable, formatted correctly, and well-tested.

Your choice of distribution strategy is usually informed by business goals and product style.
If you're making installed software, it's common to keep the source code secret to avoid giving away your entire revenue stream.
But if you are building a service accessed over the Internet, having your code public may not matter when it comes to making money.


### Which C?
You may not know that there are several flavors of C.
This is understandable; the core of the language is nearly unchanged since the first publication of *The C Programming Language* in 1978.

The one you're probably aware of is C89, which is the name given to the ISO adoption given to the 1983 ANSI standardization of the language.
This version is very close to the original specification, and is the most commonly-supported dialect; it's hard to find a compiler that *won't* compile C89.

But it's missing some things, and the standard was revised in 1999 to include some very useful features that had been released in proprietary compilers and C++.
This dialect is called C99, and support for it varies from compiler to compiler.

Your choice of distribution method will help inform this decision – if you're distributing source code, you may need compatibility with compilers that can't handle C99, but if you have complete control over your toolchain, it's probably desirable to choose a set that supports the new features.
Happy developers are productive developers.


## Tactical tools
There's a standard set of tools that you'll be needing every day, no matter what your environment is.
I like to call these *tactical tools*, since they may change over the life of a project, without materially changing the goal  or content of the project itself.
These decisions are important, because there is always a cost to switching, but the cost isn't so high as to make the decision irreversible.

### Compilers
Sadly, computers don't execute C.
At some point, someone or something is going to have to translate what you've written into binary instructions that will flow like water through the doped-silicon pathways of some stranger's computer.

Compilers are not at all a solved problem.
Rather than coalescing into a field with maybe three players (as desktop and mobile operating systems have), a thousand flowers have bloomed.
Many compilers are free, some are very expensive, and it seems like a new one comes out every couple of years.

The main thing here is to know which compilers your code will need to work with.
This largely depends on your distribution strategy – if your final product is built binaries, just pick a compiler and use it to the fullest.
If your project is open-source and needs to *build* on strangers' computers, you'll need to test under the compilers your users are most likely to have.

If you need to support more than one compiler or development environment, it's worth considering using a meta-build tool such as **CMake** or **gyp**.
These allow you to define your project in general terms (*these* are the source files, *this* is what the output name should be, etc.), and the tool can generate a variety of project files, and even build the system for you using the toolchain that's available.
There's effort involved in writing and maintaining the meta-project file, but it can more than pay for itself by providing access to many different environments, even if only temporarily (see below).
This approach also lets you avoid maintaining multiple tool-specific project files, and allows people working on the code to choose the environment that works best for them.

**TODO: example**

If you google for meta-build tools, you'll probably run across *Autotools*.
Try to think of it in the same terms as *RCS* or *CVS* (see below); at this point in time, there's almost no reason to use a tool so byzantine and difficult, when so many better options exist.


### Editors
One's choice of text editor is a very personal matter, but it must be said that some editors are better at C than others.

IDEs such as **Microsoft Visual Studio**, **Eclipse CDT** or **XCode** can be very useful.
They have extensive tools for graphical debugging, performance measurement, syntax-aware code navigation, and a host of other useful features.
These tools are designed around the *"edit-compile-run"* cycle, and common tasks are made very easy.
Their main drawback is their specificity; it's difficult to get Visual Studio to work with another toolchain, or to compile a binary for Linux, for example.

Raw-text powerhouses like **Emacs** and **Vim** are much better at raw text manipulation, with features like macro recording and ultimate customizability.
But since they aren't tied to a particular toolchain, it takes a bit of monkeying to get them to support the same kind of features that IDEs do.
The other side to this coin is sheer flexibility; these editors allow you to customize nearly everything about their behavior, and they have rich ecosystems of plugins and extensions to prove it.


### Debuggers
If you're using an IDE, you already have a debugger.
But if you're using a raw-text editor, you get to choose one.

Many compiler toolchains come with a debugger (gcc comes with **gdb**, clang with **lldb**, etc.).
There is a steep learning curve with CLI-based debugging tools, but climbing it can be well worth your time.
As with Vim or Emacs, you gain intimate understanding and muscle-memory speed when you choose a tool designed for use with only a keyboard.

Occasionally, you'll run across a problem that's *much* easier to solve in a different debugger.
This is a case where using a meta-project generator can save you many hours.
You may do most of your editing with your favorite editor, and when you need the specialized tools included with Xcode, for example, you simply generate a project file.
Even if you're only planning on building with one compiler, this technique can make it possible to use the best tool for each job, rather than being stuck with the tools you chose on day one.


### Analyzers
Automated checking tools can catch many serious bugs before they even go into source control.
These come in two flavors: static and dynamic.

Static code analyzers work by parsing and crunching the source code without actually running it.
You're actually using one of these already: your compiler. 
It's pretty good at finding type errors, and not terribly bad at detecting certain other kinds of error, though compilers have their limits.
There are other analysis tools that are free (**scan-build** is included with clang and is also available from inside Xcode, and Eclipse CDT includes **CODAN**, for example) or included with tools you already have (certain versions of Visual Studio include static code analysis).
Stand-alone commercial tools also exist, such as **PC-Lint** and **PVS-Studio**.
The main drawback of static analysis tools is their pedantry.
Often these tools will find problems that aren't worth the effort to fix, or false positives.
It takes some effort to tune the tool to your team's particular coding style and requirements.

Dynamic tools work by analyzing data about your program while it's running.
Usually these are focused on watching memory allocations, CPU usage, or I/O, and they are sometimes called profilers.
Xcode ships with several excellent tools, and certain versions of Visual Studio do as well.
**Valgrind** is the king of the hill in the open source world, and should be on every C developer's utility belt.
It includes an extensive set of debugging and profiling tools.
These tools can save you many hours of debugging when (not if) memory corruption errors happen.
If your native development platform can't run valgrind, it may be worth using a meta-build tool and spinning up a Linux virtual machine to use it.


### Collaboration Tools
Working with others is essential to having a successful project.
For a simple project with a small team, you can probably get by with face-to-face communication and a pad of paper, but more complex situations demand more sophisticated tools.

One thing you'll need, without exception, is a version control system (VCS).
Choosing one seems fairly arbitrary at first, but the capabilities of your tool will shape the kinds of actions you can take later on.
I highly recommend using one of the newest generation, so-called "distributed" version control tools, like **Git** or **Mercurial**.
Your team may grumble if they're not used to them, but within a few months they probably won't be able to imagine going back to a centralized system.
But please don't use *RCS* or *CVS*; there's no reason to choose them over something like **Subversion**.

You'll also need to be able to communicate with your team, both asynchronously and in real-time.
Asynchronous tools include things like bug trackers, discussion boards, wikis, and even the API documentation extracted from code comments.
Think of these as places where decisions have URLs, so you can refer to them later.
Each kind of tool has its place, but your choice of which to use will be informed by the way your team works together.

You'll also need synchronous communication for rapid feedback.
If your team consists of one person, or work in the same physical space, this problem is already solved; humans are great at sharing ideas in an environment such as this.
But if neither of these facts is 100% true, you'll need some software to back you up.
This is generally called *chat software*, and includes things like **Campfire** and **HipChat**.
**IRC** can also be useful, but it lacks a critical capability: full, searchable transcripts.

The ecosystem for collaboration tools is both broad and deep.
If you want a curated set of collaboration tools, a bundle of decisions that have already been made for you and wrapped up with a bow, you can find that too.
Toolsets like **GitHub** have been crafted with a team workflow in mind, and will work very well if you stick to their constraints.
Other packages, such as products from Atlassian or Microsoft, are *extensively* customizable, and can be tailored to your specific needs.


## Strategic Tools
Writing and running code is what you're going to be doing every day, but there are several important practices that will help you succeed over a longer time span.
I think of these as *strategic* because both their costs and benefits are felt in a different time-frame than their introduction.


### Unit Testing
Once you've written all that code, you probably want to make sure it does what you think it does.
Unit testing has become a standard part of software discipline.
While it's certainly an option to not have any automated testing at all, it's not a path commonly followed.

So you probably want unit tests.
C doesn't have many features that make writing those tests easier or more concise.
You can start completely from scratch if you like, but I recommend using a framework.
My personal favorite is **Clar**, which requires Python to be installed, but parses your source code and builds the suites and runners for you based on naming conventions.
This makes it feel like you're writing in Ruby with no boilerplate.
Listing 1 shows a sample Clar test suite.

##### Listing 1
```c
#include "clar.h"

// This test file is named sample/first.c, thus the 
// function name prefixes

// Fixture set-up and tear-down. These run between every test case.
void test_sample_first__initialize(void)
{}
void test_sample_first__cleanup(void)
{}

// Names that don't begin with test_sample_first__ are ignored by clar
int a_utility(int x)
{
	return x - 12;
}

// A test case
void test_sample_first__a_simple_test(void)
{
	cl_assert_equal_i(0, a_utility(12));
}

```

Other frameworks are available if you don't like Clar's style; try **Check** or **CUnit**; both require more boilerplate, but there's less magic.


### Continuous Integration
Once you have a suite of automated tests, you'll want to run them as often as you can.
Usually each developer will make sure their work doesn't break the tests before they push it to the rest of the team, but especially if your code is meant to compile and run in multiple environments, it's useful to have a machine do all the drudgery of checking every combination.

There are many options in this space, both free and commercial.
Some of the most popular are **Jenkins**, **TeamCity**, and **Bamboo**.
If your code is hosted on GitHub, **Travis CI** (which is free for public repostories) will even run the test script on *every pull request*, which is invaluable for accepting contributions from strangers.
Listing 2 shows the `.travis.yml` file from libgit2, including the Valgrind post-step.

##### Listing 2
```yaml
# Travis-CI Build for libgit2
# see travis-ci.org for details

# As CMake is not officially supported we use C VMs
language: c

compiler:
  - gcc
  - clang

# Settings to try
env:
  - OPTIONS="-DTHREADSAFE=ON -DCMAKE_BUILD_TYPE=Release"
  - OPTIONS="-DBUILD_CLAR=ON -DBUILD_EXAMPLES=ON"

matrix:
 include:
   - compiler: i586-mingw32msvc-gcc
     env: OPTIONS="-DBUILD_CLAR=OFF -DWIN32=ON -DMINGW=ON"

# Make sure CMake is installed
install:
 - sudo apt-get update >/dev/null
 - sudo apt-get -q install cmake valgrind

# Run the Build script
script:
 - mkdir _temp
 - git init --bare _temp/test.git
 - git daemon --listen=localhost --export-all --enable=receive-pack --base-path=_temp _temp 2>/dev/null &
 - export GITTEST_REMOTE_URL="git://localhost/test.git"
 - mkdir _build
 - cd _build
 - cmake .. -DCMAKE_INSTALL_PREFIX=../_install $OPTIONS
 - cmake --build . --target install
 - ctest -V .

# Run Tests
after_success:
 - valgrind --leak-check=full --show-reachable=yes --suppressions=../libgit2_clar.supp ./libgit2_clar -ionline

# Only watch the development branch
branches:
 only:
   - development

# Notify development list when needed
notifications:
 irc:
  channels:
    - irc.freenode.net#libgit2
  on_success: change
  on_failure: always
  use_notice: true
  skip_join: true
 campfire:
  on_success: always
  on_failure: always
  rooms:
   - secure: "sH0dpPWMirbEe7AvLddZ2yOp8rzHalGmv0bYL/LIhVw3JDI589HCYckeLMSB\n3e/FeXw4bn0EqXWEXijVa4ijbilVY6d8oprdqMdWHEodng4KvY5vID3iZSGT\nxylhahO1XHmRynKQLOAvxlc93IlpVW38vQfby8giIY1nkpspb2w="
```

### Dependency Management
C has been around for almost 40 years now, and vast quantities of high-quality code have been written and released as open source.
It seems like you should be able to use a lot of that work in your own project.

Other languages have made this really easy.
Ruby has gems, Node has npm, C# has NuGet.
Unfortunately, there isn't anything like this for C.
Mostly this is because C is so structureless and malleable, and there's no *best* way to make a reusable library.
Probably the most pragmatic way to take a dependency on an external library or toolkit is to pull in its source code using your version control tool (**git submodules** or **mercurial subrepositories**), and compile it as part of your build.
Every situation is different, and every library has its own unique way of building, so you'll have to do most of the legwork yourself.


## Learning
Your journey down the path of C will not be without bumps.
You'll stumble, you'll be confused, and the language will seem to fight you.
C has become a small niche in the world of programming, so C-focused conferences, blogs, and magazines are few and far between, but there *are* resources to draw on.


### Self-Guided Learning
The materials at **cprogramming.com** are a good jumping-off point for sharpening your C skills.
There are tutorials for every level, and sometimes learning a completely different application can help you think of your problems in a different way.

Much of your programming day will be spent typing, so it's important (especially if you've chosen your text editor for efficiency) to get better.
**typing.io** is a good place to build muscle memory for the unique statement patterns you'll find in C.


### Asking Questions
Probably the best way to ensure you get the help you need is to find a mentor.
A master practitioner can help you get through many a hard day.

If a C wizard is nowhere to be found, or you've left the bounds of your team's expertise, try **stackoverflow.com**.
This is the single best technically-focused question-and-answer resource on the Internet, and C experts from around the world are waiting to help you out.
It's also fun to help out other newbies while you're there.


### CDecl
The declaration syntax for C can sometimes be confusing, and some of the grammatical rules are hard to remember.
If you find yourself trapped in a maze of twisty little `const`s, all alike, you can use **cdecl** to find your way out.
Cdecl is a command-line tool that translates between dense C syntax and (mostly) plain English.
You can install it on your workstation, or try it out at *http://cdecl.org*.


### Reading Code
The best way to learn what good C code looks like is to read a lot of it.
This is possible now like never before; many popular and high-quality code bases are completely open source, and access is free to anyone who cares to look.
Try reading the code to **Redis**, or even one of the schedulers in the **Linux kernel**.
Or browse the **C category on GitHub**; many of the most important pieces of software in the world are available for tinkering with.


## Go Forth
The way of C is not an easy one, but it's not as hard as it used to be.
The set of tools available is more extensive than it's ever been, and creating amazing things is more accessible than at any point in computing history.
As with any language, your experience with C will be deeply affected by how you use technology to help you work with it.
